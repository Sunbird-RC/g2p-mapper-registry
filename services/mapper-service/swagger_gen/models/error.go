// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Error Describes an error object that is returned to standard post call request. <br>
// 1. This object shall be sent when any request received by a participant is not parsable or message integrity check fails. <br>
// 2. This object may be used across all transport protocols to acknowledge the receipt of a message i.e HTTPS, FTP, Messaging etc., <br>"
//
// swagger:model Error
type Error struct {

	// Standard error code
	// Enum: [err.request.bad err.request.unauthorized err.request.forbidden err.request.not_found err.request.timeout err.version.not_supported err.request.too_many_requests err.sender_id.invalid err.sender_uri.invalid err.receiver_id.invalid err.signature.missing err.signature.invalid err.encryption.invalid err.service.unavailable]
	Code string `json:"code,omitempty"`

	// message to describe above error code
	// Max Length: 999
	Message string `json:"message,omitempty"`
}

// Validate validates this error
func (m *Error) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var errorTypeCodePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["err.request.bad","err.request.unauthorized","err.request.forbidden","err.request.not_found","err.request.timeout","err.version.not_supported","err.request.too_many_requests","err.sender_id.invalid","err.sender_uri.invalid","err.receiver_id.invalid","err.signature.missing","err.signature.invalid","err.encryption.invalid","err.service.unavailable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		errorTypeCodePropEnum = append(errorTypeCodePropEnum, v)
	}
}

const (

	// ErrorCodeErrDotRequestDotBad captures enum value "err.request.bad"
	ErrorCodeErrDotRequestDotBad string = "err.request.bad"

	// ErrorCodeErrDotRequestDotUnauthorized captures enum value "err.request.unauthorized"
	ErrorCodeErrDotRequestDotUnauthorized string = "err.request.unauthorized"

	// ErrorCodeErrDotRequestDotForbidden captures enum value "err.request.forbidden"
	ErrorCodeErrDotRequestDotForbidden string = "err.request.forbidden"

	// ErrorCodeErrDotRequestDotNotFound captures enum value "err.request.not_found"
	ErrorCodeErrDotRequestDotNotFound string = "err.request.not_found"

	// ErrorCodeErrDotRequestDotTimeout captures enum value "err.request.timeout"
	ErrorCodeErrDotRequestDotTimeout string = "err.request.timeout"

	// ErrorCodeErrDotVersionDotNotSupported captures enum value "err.version.not_supported"
	ErrorCodeErrDotVersionDotNotSupported string = "err.version.not_supported"

	// ErrorCodeErrDotRequestDotTooManyRequests captures enum value "err.request.too_many_requests"
	ErrorCodeErrDotRequestDotTooManyRequests string = "err.request.too_many_requests"

	// ErrorCodeErrDotSenderIDDotInvalid captures enum value "err.sender_id.invalid"
	ErrorCodeErrDotSenderIDDotInvalid string = "err.sender_id.invalid"

	// ErrorCodeErrDotSenderURIDotInvalid captures enum value "err.sender_uri.invalid"
	ErrorCodeErrDotSenderURIDotInvalid string = "err.sender_uri.invalid"

	// ErrorCodeErrDotReceiverIDDotInvalid captures enum value "err.receiver_id.invalid"
	ErrorCodeErrDotReceiverIDDotInvalid string = "err.receiver_id.invalid"

	// ErrorCodeErrDotSignatureDotMissing captures enum value "err.signature.missing"
	ErrorCodeErrDotSignatureDotMissing string = "err.signature.missing"

	// ErrorCodeErrDotSignatureDotInvalid captures enum value "err.signature.invalid"
	ErrorCodeErrDotSignatureDotInvalid string = "err.signature.invalid"

	// ErrorCodeErrDotEncryptionDotInvalid captures enum value "err.encryption.invalid"
	ErrorCodeErrDotEncryptionDotInvalid string = "err.encryption.invalid"

	// ErrorCodeErrDotServiceDotUnavailable captures enum value "err.service.unavailable"
	ErrorCodeErrDotServiceDotUnavailable string = "err.service.unavailable"
)

// prop value enum
func (m *Error) validateCodeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, errorTypeCodePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Error) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(m.Code) { // not required
		return nil
	}

	// value enum
	if err := m.validateCodeEnum("code", "body", m.Code); err != nil {
		return err
	}

	return nil
}

func (m *Error) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	if err := validate.MaxLength("message", "body", m.Message, 999); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this error based on context it is used
func (m *Error) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Error) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Error) UnmarshalBinary(b []byte) error {
	var res Error
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
